From 83efaaf64af711c2f4cf29a64798fe594fc34af1 Mon Sep 17 00:00:00 2001
From: William Hua <william.hua@canonical.com>
Date: Wed, 28 Sep 2016 18:33:24 -0400
Subject: [PATCH] gtkcombobox: pass trigger event when popping up menu

https://bugzilla.gnome.org/show_bug.cgi?id=771242
---
 gtk/gtkcombobox.c | 38 +++++++++++++++++---------------------
 1 file changed, 17 insertions(+), 21 deletions(-)

diff --git a/gtk/gtkcombobox.c b/gtk/gtkcombobox.c
index 2e0976e629..63d130ffab 100644
--- a/gtk/gtkcombobox.c
+++ b/gtk/gtkcombobox.c
@@ -156,8 +156,7 @@ struct _GtkComboBoxPrivate
   gulong reordered_id;
   gulong changed_id;
   guint popup_idle_id;
-  guint activate_button;
-  guint32 activate_time;
+  GdkEvent *trigger_event;
   guint scroll_timer;
   guint resize_idle_id;
 
@@ -401,8 +400,7 @@ static gboolean gtk_combo_box_menu_key_press       (GtkWidget        *widget,
                                                     GdkEventKey      *event,
                                                     gpointer          data);
 static void     gtk_combo_box_menu_popup           (GtkComboBox      *combo_box,
-                                                    guint             button,
-                                                    guint32           activate_time);
+                                                    const GdkEvent   *trigger_event);
 
 /* cell layout */
 static GtkCellArea *gtk_combo_box_cell_layout_get_area       (GtkCellLayout    *cell_layout);
@@ -2105,9 +2103,8 @@ update_menu_sensitivity (GtkComboBox *combo_box,
 }
 
 static void
-gtk_combo_box_menu_popup (GtkComboBox *combo_box,
-                          guint        button,
-                          guint32      activate_time)
+gtk_combo_box_menu_popup (GtkComboBox    *combo_box,
+                          const GdkEvent *trigger_event)
 {
   GtkComboBoxPrivate *priv = combo_box->priv;
   GtkTreePath *path;
@@ -2174,7 +2171,7 @@ gtk_combo_box_menu_popup (GtkComboBox *combo_box,
                                 gtk_bin_get_child (GTK_BIN (combo_box)),
                                 GDK_GRAVITY_SOUTH_WEST,
                                 GDK_GRAVITY_NORTH_WEST,
-                                NULL);
+                                trigger_event);
     }
   else
     {
@@ -2226,7 +2223,7 @@ gtk_combo_box_menu_popup (GtkComboBox *combo_box,
                                 GTK_WIDGET (combo_box),
                                 GDK_GRAVITY_WEST,
                                 GDK_GRAVITY_NORTH_WEST,
-                                NULL);
+                                trigger_event);
     }
 }
 
@@ -2317,9 +2314,7 @@ gtk_combo_box_popup_for_device (GtkComboBox *combo_box,
 
   if (GTK_IS_MENU (priv->popup_widget))
     {
-      gtk_combo_box_menu_popup (combo_box,
-                                priv->activate_button,
-                                priv->activate_time);
+      gtk_combo_box_menu_popup (combo_box, priv->trigger_event);
       return;
     }
 
@@ -2815,7 +2810,7 @@ gtk_combo_box_menu_button_press (GtkWidget      *widget,
           !gtk_widget_has_focus (priv->button))
         gtk_widget_grab_focus (priv->button);
 
-      gtk_combo_box_menu_popup (combo_box, event->button, event->time);
+      gtk_combo_box_menu_popup (combo_box, (const GdkEvent *) event);
 
       return TRUE;
     }
@@ -4167,6 +4162,8 @@ gtk_combo_box_destroy (GtkWidget *widget)
       priv->popup_idle_id = 0;
     }
 
+  g_clear_pointer (&priv->trigger_event, gdk_event_free);
+
   if (priv->box)
     {
       /* destroy things (unparent will kill the latest ref from us)
@@ -4419,9 +4416,9 @@ popup_idle (gpointer data)
                 NULL);
   gtk_combo_box_popup (combo_box);
 
+  g_clear_pointer (&priv->trigger_event, gdk_event_free);
+
   priv->popup_idle_id = 0;
-  priv->activate_button = 0;
-  priv->activate_time = 0;
 
   return FALSE;
 }
@@ -4462,13 +4459,12 @@ gtk_combo_box_start_editing (GtkCellEditable *cell_editable,
   if (priv->is_cell_renderer &&
       priv->cell_view && !priv->tree_view)
     {
-      if (event && event->type == GDK_BUTTON_PRESS)
-        {
-          GdkEventButton *event_button = (GdkEventButton *)event;
+      g_clear_pointer (&priv->trigger_event, gdk_event_free);
 
-          priv->activate_button = event_button->button;
-          priv->activate_time = event_button->time;
-        }
+      if (event)
+        priv->trigger_event = gdk_event_copy (event);
+      else
+        priv->trigger_event = gtk_get_current_event ();
 
       priv->popup_idle_id =
           gdk_threads_add_idle (popup_idle, combo_box);
From e723fd6a238d52f9c458e8d442f2327644ab5016 Mon Sep 17 00:00:00 2001
From: Daniel Boles <dboles@src.gnome.org>
Date: Thu, 1 Dec 2016 12:38:43 +0000
Subject: [PATCH] ComboBox: Do not select item before menu realised

For a menu mode CB with wrap_width == 0 and an active item, that item is
selected in gtk_combo_box_menu_popup. Selection causes the MenuShell to
activate and hence take a grab. This was done before the menu was popped
up. A patch distributed in Debian sid - after being proposed on our BZ -
revealed that on the 1st popup of any such ComboBox, within grab_add,
the MenuShell's toplevel's GdkWindow is NULL. This causes a Gdk-CRITICAL
assertion fail on the 1st time opening any such CB, on Debian and if
that patch were merged to GTK+. By selecting after popup, we ensure the
MenuShell is realised before its grab_add and so avoid the critical.

https://bugzilla.gnome.org/show_bug.cgi?id=771242
---
 gtk/gtkcombobox.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/gtk/gtkcombobox.c b/gtk/gtkcombobox.c
index cc0bfa61f8..3dff9f810f 100644
--- a/gtk/gtkcombobox.c
+++ b/gtk/gtkcombobox.c
@@ -1702,6 +1702,7 @@ gtk_combo_box_menu_popup (GtkComboBox    *combo_box,
   gint rect_anchor_dy = -2;
   gint child_height;
   GtkWidget *active;
+  GtkWidget *select;
   GtkWidget *child;
   GList *i;
 
@@ -1761,10 +1762,9 @@ gtk_combo_box_menu_popup (GtkComboBox    *combo_box,
     {
       /* FIXME handle nested menus better */
       active = gtk_menu_get_active (GTK_MENU (priv->popup_widget));
+      select = active;
 
-      if (active)
-        gtk_menu_shell_select_item (GTK_MENU_SHELL (priv->popup_widget), active);
-      else
+      if (!active)
         {
           for (i = GTK_MENU_SHELL (priv->popup_widget)->priv->children; i && !active; i = i->next)
             {
@@ -1808,6 +1808,9 @@ gtk_combo_box_menu_popup (GtkComboBox    *combo_box,
                                 GDK_GRAVITY_WEST,
                                 GDK_GRAVITY_NORTH_WEST,
                                 trigger_event);
+
+      if (select)
+        gtk_menu_shell_select_item (GTK_MENU_SHELL (priv->popup_widget), select);
     }
 }
 
From e4ede33a650d91804327f052c76322ff06d26a95 Mon Sep 17 00:00:00 2001
From: Daniel Boles <dboles@src.gnome.org>
Date: Wed, 18 Jan 2017 22:22:52 +0000
Subject: [PATCH] combobox: Work around popup handler altering model
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

GtkFileChooserButton installs a handler for the popped-up signal, which
refilters the menu, in order to hide the “(None)” item from the popup
if it was previously selected in the ComboBox. This oddity means that:

 • Until recently, this item would be selected in the menu shell, which
   would then be popped up and change the selection away from that item.
   This was therefore redundant (more on which below!) but benign.

 • After the patch for https://bugzilla.gnome.org/show_bug.cgi?id=771242
   however, this causes a critical assertion fail, as now we stash the
   originally selected item in a pointer so that it can be selected only
   after realisation/popup – but by that stage, the model has just been
   refiltered and the previous pointer no longer refers to a valid item.

This commit works around this problem by, after popping up the menu,
getting the active item again, in case a popped-up handler has gone and
invalidated the pointer to the active item that we saved before popup.

If a handler does this, everything done to find/use the original item is
pointless. But this avoids the ugly critical in FileChooserButton, while
not harming every other ComboBox that doesn’t mess with its model while
popping up (hopefully the vast majority), and it’s very difficult to
imagine a way to check if the active item is /going to/ be hidden later)
---
 gtk/gtkcombobox.c | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/gtk/gtkcombobox.c b/gtk/gtkcombobox.c
index 4b3c9f8703..8173876d36 100644
--- a/gtk/gtkcombobox.c
+++ b/gtk/gtkcombobox.c
@@ -1755,7 +1755,6 @@ gtk_combo_box_menu_popup (GtkComboBox    *combo_box,
     {
       /* FIXME handle nested menus better */
       GtkWidget *active = gtk_menu_get_active (GTK_MENU (priv->popup_widget));;
-      GtkWidget *select = active;
       gint rect_anchor_dy = -2;
       GList *i;
       GtkWidget *child;
@@ -1807,8 +1806,13 @@ gtk_combo_box_menu_popup (GtkComboBox    *combo_box,
                                 GDK_GRAVITY_NORTH_WEST,
                                 trigger_event);
 
-      if (select)
-        gtk_menu_shell_select_item (GTK_MENU_SHELL (priv->popup_widget), select);
+      /* As a hack, re-get the active item, in case a popup handler, like that
+       * of FileChooserButton, just caused the menu to be refiltered, making the
+       * previous active item pointer invalid now. This seems pretty ugly and
+       * makes the y-offset loop pointless for such cases, so FIXME later? */
+      active = gtk_menu_get_active (GTK_MENU (priv->popup_widget));
+      if (active)
+        gtk_menu_shell_select_item (GTK_MENU_SHELL (priv->popup_widget), active);
     }
 }
 
